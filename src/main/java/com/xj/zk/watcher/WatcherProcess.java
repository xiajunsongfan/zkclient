package com.xj.zk.watcher;import com.xj.zk.ZkClient;import com.xj.zk.ZkClientException;import com.xj.zk.listener.Listener;import com.xj.zk.listener.ListenerManager;import com.xj.zk.listener.ListenerProcessPool;import com.xj.zk.listener.Node;import org.apache.zookeeper.Watcher.Event.EventType;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.net.SocketException;import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;/** * Author: xiajun * Date: 14/5/20 * zookeeper watch事件处理类 */public class WatcherProcess {    private final static Logger LOGGER = LoggerFactory.getLogger(WatcherProcess.class);    private ZkClient zkClient;    private final ConcurrentHashMap<String, ListenerManager> nodeListenerPool = new ConcurrentHashMap<String, ListenerManager>();//节点监听池    private final ConcurrentHashMap<String, ListenerManager> dataListenerPool = new ConcurrentHashMap<String, ListenerManager>();//数据监听池    private final ConcurrentHashMap<String, Node> stubbornNodePool = new ConcurrentHashMap<String, Node>();//坚固的节点（顽固），服务重链后节点自动注册    private ListenerProcessPool listenerPool = null;    /**     * @param zkClient         ZkClinet对象用于操作zookeeper     * @param listenerPoolSize zookeeper事件触发后的回调执行线程池大小     */    public WatcherProcess(ZkClient zkClient, int listenerPoolSize) {        this.zkClient = zkClient;        listenerPool = new ListenerProcessPool(listenerPoolSize);    }    /**     * watch事件处理类     * 设置处理监听事件线程数为2     * @param zkClient     */    public WatcherProcess(ZkClient zkClient) {        this(zkClient, 2);    }    /**     * 设置监听对象，当监听的事件发生时将回调listen()方法     *     * @param path     * @param listenChildNode ture 为监听子节点变化，false为监听本节点数据变化     * @throws org.apache.zookeeper.KeeperException     * @throws InterruptedException     */    public void listen(String path, Listener listener, boolean listenChildNode, boolean childData) throws ZkClientException {        try {            ListenerManager manager = new ListenerManager(listener, childData);            if (listenChildNode) {                nodeListenerPool.put(path, manager);                childChange(path, true);            } else {                dataListenerPool.put(path, manager);                this.dataChange(path);            }        } catch (Exception e) {            throw new ZkClientException("Listen node " + path, e);        }    }    /**     * 取消节点监听     *     * @param path  节点地址     * @param child true表示监听子节点变化，false表示监听节点数据变化     */    public void unlisten(String path, boolean child) throws ZkClientException {        if (child) {            if (zkClient.exists(path)) {                this.zkClient.getChild(path, false);            }            nodeListenerPool.remove(path);        } else {            if (zkClient.exists(path)) {                this.zkClient.getData(path, false);            }            dataListenerPool.remove(path);        }    }    /**     * 当session超时重连后，重新注册监听事件     */    public void relisten() throws ZkClientException {        for (Map.Entry<String, ListenerManager> entry : dataListenerPool.entrySet()) {            this.dataChange(entry.getKey());            LOGGER.debug("Relisten data node:{}", entry.getKey());        }        for (Map.Entry<String, ListenerManager> entry : nodeListenerPool.entrySet()) {            this.childChange(entry.getKey(), false);            LOGGER.debug("Relisten child node:{}", entry.getKey());        }        for (Map.Entry<String, Node> entry : stubbornNodePool.entrySet()) {            Node node = entry.getValue();            this.zkClient.create(node.getPath(), node.getData(), false);            LOGGER.debug("Recreate (stubborn node) node:{}", entry.getKey());        }    }    /**     * 节点数据变化处理函数     *     * @param path 变化的节点     */    public void dataChange(String path) throws ZkClientException {        try {            if (dataListenerPool.containsKey(path)) {                byte[] data = this.zkClient.getData(path, true);                ListenerManager manager = dataListenerPool.get(path);                ListenerManager lm = new ListenerManager(manager.getListener());                lm.setData(data);                lm.setEventType(EventType.NodeDataChanged);                listenerPool.invoker(path, lm);                LOGGER.debug("node:{} data change.", path);            }        } catch (Exception e) {            throw new ZkClientException("Listener data change error.", e);        }    }    /**     * 子节点变化处理函数     *     * @param path 节点路径     * @param init 是否是初次监听，第一次监听将阻塞返回结果     */    public void childChange(String path, boolean init) throws ZkClientException {        if (nodeListenerPool.containsKey(path)) {            try {                List<String> changeNodes = this.zkClient.getChild(path, true);                ListenerManager manager = nodeListenerPool.get(path);                List<String> oldNodes = this.diff(path, changeNodes, manager, init);                manager.setChildNode(oldNodes);            } catch (Exception e) {                throw new ZkClientException("Listener client node change error.", e);            }        }    }    /**     * 检查子节点变化     *     * @param changeList 变化后的子节点集合     * @return     */    private List<String> diff(String path, List<String> changeList, ListenerManager manager, boolean init) throws ZkClientException, SocketException {        if (changeList == null) {            changeList = new ArrayList<String>();        }        List<String> oldList = manager.getChildNode();        if (oldList == null) {            oldList = new ArrayList<String>();        }        for (int i = 0; i < oldList.size(); i++) {            String node = oldList.get(i);            if (!changeList.contains(node)) {                oldList.remove(node);                i--;                String cpath = path + "/" + node;                if (manager.isChildData()) {                    unlisten(cpath, false);                }                ListenerManager lm = new ListenerManager(manager.getListener());                lm.setData(new byte[1]);                lm.setEventType(EventType.NodeDeleted);                listenerPool.invoker(cpath, lm);                LOGGER.debug("node:{} child change,type:node-delete", node);            }        }        for (String node : changeList) {            if (!oldList.contains(node)) {                oldList.add(node);                String cpath = path + "/" + node;                if (!manager.isChildData()) {                    ListenerManager lm = new ListenerManager(manager.getListener());                    lm.setData(new byte[1]);                    lm.setEventType(EventType.NodeCreated);                    if (!init) {                        listenerPool.invoker(cpath, lm);                    } else {                        manager.getListener().listen(cpath, EventType.NodeCreated, new byte[1]);                    }                } else {                    listen(cpath, manager.getListener(), false, false);                }                LOGGER.debug("node:{} child change,type:node-create", node);            }        }        return oldList;    }    /**     * 创建一个顽固的临时节点，当会话断开时删除，重连后自动创建     *     * @param path     * @param data     * @throws ZkClientException     */    public void stubborn(String path, byte[] data) throws ZkClientException {        if (path != null && data != null) {            Node node = new Node();            node.setPath(path);            node.setData(data);            stubbornNodePool.put(path, node);            LOGGER.debug("Stubborn node create success,node:{}", node);        } else {            throw new ZkClientException("Create node error,node = null or data = null.");        }    }}